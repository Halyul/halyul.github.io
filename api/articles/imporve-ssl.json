{"title":"失踪人口回归系列之增强站点SSL安全性","slug":"imporve-ssl","date":"2017-03-22T11:39:00.000Z","updated":"2017-11-25T09:58:00.000Z","comments":true,"path":"api/articles/imporve-ssl.json","excerpt":"失踪人口回归系列之第二篇","covers":null,"content":"<p>失踪人口回归系列之第二篇</p>\n<a id=\"more\"></a>\n\n<p>经过这篇文章后，我的SSL Lab的测试也是A+了。</p>\n<ul>\n<li>原文地址：<a href=\"https://raymii.org/s/tutorials/Strong_SSL_Security_On_nginx.html\" target=\"_blank\" rel=\"noopener\">https://raymii.org/s/tutorials/Strong_SSL_Security_On_nginx.html</a></li>\n<li>原文作者：<a href=\"https://raymii.org/\" target=\"_blank\" rel=\"noopener\">Remy van Elst</a></li>\n<li>译者与校对：<a href=\"https://github.com/wxy\" target=\"_blank\" rel=\"noopener\">wxy</a></li>\n<li>本文由<a href=\"https://github.com/LCTT/TranslateProject\" target=\"_blank\" rel=\"noopener\">LCTT</a>原创翻译，<a href=\"http://linux.cn/\" target=\"_blank\" rel=\"noopener\">Linux中国</a> 荣誉推出</li>\n<li>此为原文重排版</li>\n</ul>\n<p>本文向你介绍如何在 nginx 服务器上设置健壮的 SSL 安全机制。我们通过禁用 SSL 压缩来降低 CRIME 攻击威胁；禁用协议上存在安全缺陷的 SSLv3 及更低版本，并设置更健壮的加密套件（cipher suite）来尽可能启用前向安全性（Forward Secrecy）；此外，我们还启用了 HSTS 和 HPKP。这样我们就拥有了一个健壮而可经受考验的 SSL 配置，并可以在 Qually Labs 的 SSL 测试中得到 A 级评分。</p>\n<p>本教程可以通过<a href=\"http://blog.ivanristic.com/2014/01/ssl-labs-stricter-security-requirements-for-2014.html\" target=\"_blank\" rel=\"noopener\">发布于 2014/1/21 的 SSL 实验室测试的严格要求</a>（我之前就通过了测试，如果你按照本文操作就可以得到一个 A+ 评分）。</p>\n<ul>\n<li><p>本教程也可用于 Apache</p>\n</li>\n<li><p>本教程也可用于 Lighttpd</p>\n</li>\n<li><p>本教程也可用于 FreeBSD, NetBSD 和 OpenBSD 上的 nginx ，放在<a href=\"http://www.bsdnow.tv/tutorials/nginx\" target=\"_blank\" rel=\"noopener\">BSD Now 播客上</a><br>你可以从下列链接中找到这方面的进一步内容：</p>\n</li>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Transport_Layer_Security#BEAST_attack\" target=\"_blank\" rel=\"noopener\">野兽攻击（BEAST）</a></p>\n</li>\n<li><p><a href=\"https://en.wikipedia.org/wiki/CRIME_%28security_exploit%29\" target=\"_blank\" rel=\"noopener\">罪恶攻击（CRIME）</a></p>\n</li>\n<li><p><a href=\"http://blog.cryptographyengineering.com/2015/03/attack-of-week-freak-or-factoring-nsa.html\" target=\"_blank\" rel=\"noopener\">怪物攻击（FREAK ）</a></p>\n</li>\n<li><p><a href=\"http://heartbleed.com/\" target=\"_blank\" rel=\"noopener\">心血漏洞（Heartbleed）</a></p>\n</li>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Perfect_forward_secrecy\" target=\"_blank\" rel=\"noopener\">完备的前向安全性（Perfect Forward Secrecy）</a></p>\n</li>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Transport_Layer_Security#Dealing_with_RC4_and_BEAST\" target=\"_blank\" rel=\"noopener\">RC4 和 BEAST 的处理</a></p>\n</li>\n</ul>\n<p><strong><big>在编辑之前切记备份一下配置文件！</big></strong></p>\n<h3 id=\"我是懒人\"><a href=\"#我是懒人\" class=\"headerlink\" title=\"我是懒人\"></a>我是懒人</h3><p>那你直接看我从<a href=\"https://cipherli.st/\" target=\"_blank\" rel=\"noopener\">Cipherli.st</a>上得到的内容复制粘贴到你的站点配置就好了。</p>\n<h4 id=\"Apache\"><a href=\"#Apache\" class=\"headerlink\" title=\"Apache\"></a>Apache</h4><pre><code>SSLCipherSuite EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH\nSSLProtocol All -SSLv2 -SSLv3\nSSLHonorCipherOrder On\n# HSTS\nHeader always set Strict-Transport-Security &quot;max-age=63072000; includeSubDomains; preload&quot;\nHeader always set X-Frame-Options DENY\nHeader always set X-Content-Type-Options nosniff\n# Apache版本 &gt;= 2.4\nSSLCompression off\nSSLUseStapling on\nSSLStaplingCache &quot;shmcb:logs/stapling-cache(150000)&quot;\n# Apache版本 &gt;= 2.4.11\nSSLSessionTickets Off</code></pre><h4 id=\"nginx\"><a href=\"#nginx\" class=\"headerlink\" title=\"nginx\"></a>nginx</h4><pre><code>ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\nssl_prefer_server_ciphers on;\nssl_ciphers &quot;EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH&quot;;\nssl_ecdh_curve secp384r1; # nginx版本 &gt;= 1.1.0\nssl_session_cache shared:SSL:10m;\nssl_session_tickets off; # nginx版本 &gt;= 1.5.9\nssl_stapling on; # Requires nginx &gt;= 1.3.7\nssl_stapling_verify on; # nginx版本 =&gt; 1.3.7\nresolver $DNS-IP-1 $DNS-IP-2 valid=300s; # 此处将$DNS-IP-1和$DNS-IP-2更换为DNS服务商的IP\nresolver_timeout 5s;\nadd_header Strict-Transport-Security &quot;max-age=63072000; #HSTS includeSubDomains; preload&quot;;\nadd_header X-Frame-Options DENY;\nadd_header X-Content-Type-Options nosniff;</code></pre><h4 id=\"Lighttpd\"><a href=\"#Lighttpd\" class=\"headerlink\" title=\"Lighttpd\"></a>Lighttpd</h4><pre><code>ssl.honor-cipher-order = &quot;enable&quot;\nssl.cipher-list = &quot;EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH&quot;\nssl.use-compression = &quot;disable&quot;\nsetenv.add-response-header = (\n    &quot;Strict-Transport-Security&quot; =&gt; &quot;max-age=63072000; includeSubDomains; preload&quot;,\n    &quot;X-Frame-Options&quot; =&gt; &quot;DENY&quot;,\n    &quot;X-Content-Type-Options&quot; =&gt; &quot;nosniff&quot;\n)\nssl.use-sslv2 = &quot;disable&quot;\nssl.use-sslv3 = &quot;disable&quot;</code></pre><h3 id=\"我不是懒人\"><a href=\"#我不是懒人\" class=\"headerlink\" title=\"我不是懒人\"></a>我不是懒人</h3><h4 id=\"方便快捷修改站点配置文件\"><a href=\"#方便快捷修改站点配置文件\" class=\"headerlink\" title=\"方便快捷修改站点配置文件\"></a>方便快捷修改站点配置文件</h4><h5 id=\"SSLv2-和-SSLv3\"><a href=\"#SSLv2-和-SSLv3\" class=\"headerlink\" title=\"SSLv2 和 SSLv3\"></a>SSLv2 和 SSLv3</h5><p>SSLv2 是不安全的，所以我们需要禁用它。我们也禁用 SSLv3，因为 TLS 1.0 在遭受到降级攻击时，会允许攻击者强制连接使用 SSLv3，从而禁用了前向安全性（forward secrecy）。</p>\n<p>编辑站点配置文件：</p>\n<pre><code>ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</code></pre><h5 id=\"加密套件（cipher-suite）\"><a href=\"#加密套件（cipher-suite）\" class=\"headerlink\" title=\"加密套件（cipher suite）\"></a>加密套件（cipher suite）</h5><p>前向安全性（Forward Secrecy）用于在长期密钥被破解时确保会话密钥的完整性。PFS（完备的前向安全性）是指强制在每个/每次会话中推导新的密钥。</p>\n<p>这就是说，泄露的私钥并不能用来解密（之前）记录下来的 SSL 通讯。</p>\n<p>提供PFS（完备的前向安全性）功能的是那些使用了一种 Diffie-Hellman 密钥交换的短暂形式的加密套件。它们的缺点是系统开销较大，不过可以使用椭圆曲线的变体来改进。</p>\n<p>以下两个加密套件是我推荐的，之后<a href=\"https://wiki.mozilla.org/Security/Server_Side_TLS\" target=\"_blank\" rel=\"noopener\">Mozilla 基金会</a>也推荐了。</p>\n<p>推荐的加密套件：</p>\n<pre><code>ssl_ciphers &#39;AES128+EECDH:AES128+EDH&#39;;</code></pre><p>向后兼容的推荐的加密套件（IE6/WinXP）：</p>\n<pre><code>ssl_ciphers &quot;ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA:ECDHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES128-SHA256:DHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES256-GCM-SHA384:AES128-GCM-SHA256:AES256-SHA256:AES128-SHA256:AES256-SHA:AES128-SHA:DES-CBC3-SHA:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!MD5:!PSK:!RC4&quot;;</code></pre><p>如果你的 OpenSSL 版本比较旧，不可用的加密算法会自动丢弃。应该一直使用上述的完整套件，让 OpenSSL 选择一个它所支持的。</p>\n<p>加密套件的顺序是非常重要的，因为其决定了优先选择哪个算法。上述优先推荐的算法中提供了PFS（完备的前向安全性）。</p>\n<p>较旧版本的 OpenSSL 也许不能支持这个算法的完整列表，AES-GCM 和一些 ECDHE 算法是相当新的，在 Ubuntu 和 RHEL 中所带的绝大多数 OpenSSL 版本中不支持。</p>\n<h5 id=\"更多设置\"><a href=\"#更多设置\" class=\"headerlink\" title=\"更多设置\"></a>更多设置</h5><p>确保你也添加了如下行：</p>\n<pre><code>ssl_prefer_server_ciphers on;\nssl_session_cache shared:SSL:10m;</code></pre><p>在一个 SSLv3 或 TLSv1 握手过程中选择一个加密算法时，一般使用客户端的首选算法。如果设置了上述配置，则会替代地使用服务器端的首选算法。</p>\n<ul>\n<li><a href=\"http://wiki.nginx.org/HttpSslModule#ssl_prefer_server_ciphers\" target=\"_blank\" rel=\"noopener\">关于 ssl_prefer_server_ciphers 的更多信息</a></li>\n<li><a href=\"http://wiki.nginx.org/HttpSslModule#ssl_ciphers\" target=\"_blank\" rel=\"noopener\">关于 ssl_ciphers 的更多信息</a></li>\n</ul>\n<h5 id=\"前向安全性和-Diffie-Hellman-Ephemeral-（DHE）参数\"><a href=\"#前向安全性和-Diffie-Hellman-Ephemeral-（DHE）参数\" class=\"headerlink\" title=\"前向安全性和 Diffie Hellman Ephemeral （DHE）参数\"></a>前向安全性和 Diffie Hellman Ephemeral （DHE）参数</h5><p>前向安全性（Forward Secrecy）的概念很简单：客户端和服务器协商一个永不重用的密钥，并在会话结束时销毁它。服务器上的 RSA 私钥用于客户端和服务器之间的 Diffie-Hellman 密钥交换签名。从 Diffie-Hellman 握手中获取的预主密钥会用于之后的编码。因为预主密钥是特定于客户端和服务器之间建立的某个连接，并且只用在一个限定的时间内，所以称作短暂模式（Ephemeral）。</p>\n<p>使用了前向安全性，如果一个攻击者取得了一个服务器的私钥，他是不能解码之前的通讯信息的。这个私钥仅用于 Diffie Hellman 握手签名，并不会泄露预主密钥。Diffie Hellman 算法会确保预主密钥绝不会离开客户端和服务器，而且不能被中间人攻击所拦截。</p>\n<p>所有版本的 nginx（如1.4.4）都依赖于 OpenSSL 给 Diffie-Hellman （DH）的输入参数。不幸的是，这意味着 Diffie-Hellman Ephemeral（DHE）将使用 OpenSSL 的默认设置，包括一个用于密钥交换的1024位密钥。因为我们正在使用2048位证书，DHE 客户端就会使用一个要比非 DHE 客户端更弱的密钥交换。</p>\n<p>我们需要生成一个更强壮的 DHE 参数：</p>\n<pre class=\"line-numbers language-bash\" mdui-tooltip=\"{content: 'bash'}\"><code class=\"language-bash\">$ <span class=\"token function\">cd</span> /etc/ssl/certs\n$ openssl dhparam -out dhparam.pem 4096<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>然后告诉 nginx 将其用作 DHE 密钥交换：</p>\n<pre><code>ssl_dhparam /etc/ssl/certs/dhparam.pem;</code></pre><h5 id=\"OCSP-装订（Stapling）\"><a href=\"#OCSP-装订（Stapling）\" class=\"headerlink\" title=\"OCSP 装订（Stapling）\"></a>OCSP 装订（Stapling）</h5><p>当连接到一个服务器时，客户端应该使用证书吊销列表（CRL）或在线证书状态协议（OCSP）记录来校验服务器证书的有效性。CRL 的问题是它已经增长的太大了，永远也下载不完了。</p>\n<p>OCSP 更轻量级一些，因为我们每次只请求一条记录。但是副作用是当连接到一个服务器时必须对第三方 OCSP 响应器发起 OCSP 请求，这就增加了延迟和带来了潜在隐患。事实上，CA 所运营的 OCSP 响应器非常不可靠，浏览器如果不能及时收到答复，就会静默失败。攻击者通过 DoS 攻击一个 OCSP 响应器可以禁用其校验功能，这样就降低了安全性。</p>\n<p>解决方法是允许服务器在 TLS 握手中发送缓存的 OCSP 记录，以绕开 OCSP 响应器。这个机制节省了客户端和 OCSP 响应器之间的通讯，称作 OCSP 装订。</p>\n<p>客户端会在它的 CLIENT HELLO 中告知其支持 status_request TLS 扩展，服务器仅在客户端请求它的时候才发送缓存的 OCSP 响应。</p>\n<p>大多数服务器最多会缓存 OCSP 响应48小时。服务器会按照常规的间隔连接到 CA 的 OCSP 响应器来获取刷新的 OCSP 记录。OCSP 响应器的位置可以从签名的证书中的授权信息访问（Authority Information Access）字段中获得。</p>\n<ul>\n<li><a href=\"https://raymii.org/s/tutorials/OCSP_Stapling_on_nginx.html\" target=\"_blank\" rel=\"noopener\">阅读我的教程：在 NGINX 中启用 OCSP 装订</a></li>\n</ul>\n<h5 id=\"HTTP-严格传输安全（HSTS）\"><a href=\"#HTTP-严格传输安全（HSTS）\" class=\"headerlink\" title=\"HTTP 严格传输安全（HSTS）\"></a>HTTP 严格传输安全（HSTS）</h5><p>如有可能，你应该启用<a href=\"https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security\" target=\"_blank\" rel=\"noopener\">HTTP 严格传输安全（HSTS）</a>，它会引导浏览器和你的站点之间的通讯仅通过 HTTPS。</p>\n<ul>\n<li><a href=\"https://linux.cn/article-5266-1.html\" target=\"_blank\" rel=\"noopener\">阅读我关于 HSTS 的文章，了解如何配置它</a></li>\n</ul>\n<h5 id=\"HTTP-公钥固定扩展（HPKP）\"><a href=\"#HTTP-公钥固定扩展（HPKP）\" class=\"headerlink\" title=\"HTTP 公钥固定扩展（HPKP）\"></a>HTTP 公钥固定扩展（HPKP）</h5><p>你也应该启用<a href=\"https://wiki.mozilla.org/SecurityEngineering/Public_Key_Pinning\" target=\"_blank\" rel=\"noopener\">HTTP 公钥固定扩展（HPKP）</a>。</p>\n<p>公钥固定的意思是一个证书链必须包括一个白名单中的公钥。它确保仅有白名单中的 CA 才能够为某个域名签署证书，而不是你的浏览器中存储的任何 CA。</p>\n<p>我已经写了一篇[]关于 HPKP 的背景理论及在 Apache、Lighttpd 和 NGINX 中配置例子的文章](<a href=\"https://linux.cn/article-5282-1.html)。\" target=\"_blank\" rel=\"noopener\">https://linux.cn/article-5282-1.html)。</a></p>\n<h4 id=\"调整服务器\"><a href=\"#调整服务器\" class=\"headerlink\" title=\"调整服务器\"></a>调整服务器</h4><h5 id=\"野兽攻击（BEAST）和-RC4\"><a href=\"#野兽攻击（BEAST）和-RC4\" class=\"headerlink\" title=\"野兽攻击（BEAST）和 RC4\"></a>野兽攻击（BEAST）和 RC4</h5><p>简单的说，野兽攻击（BEAST）就是通过篡改一个加密算法的 CBC（密码块链）的模式，从而可以对部分编码流量悄悄解码。更多信息参照上面的链接。</p>\n<p>针对野兽攻击（BEAST），较新的浏览器已经启用了客户端缓解方案。推荐方案是禁用 TLS 1.0 的所有加密算法，仅允许 RC4 算法。然而，[]针对 RC4 算法的攻击也越来越多](<a href=\"http://www.isg.rhul.ac.uk/tls/\" target=\"_blank\" rel=\"noopener\">http://www.isg.rhul.ac.uk/tls/</a>) ，很多已经从理论上逐步发展为实际可行的攻击方式。此外，有理由相信 NSA 已经实现了他们所谓的“大突破”——攻破 RC4 。</p>\n<p>禁用 RC4 会有几个后果。其一，当用户使用老旧的浏览器时，比如 Windows XP 上的 IE 会用 3DES 来替代 RC4。3DES 要比 RC4 更安全，但是它的计算成本更高，你的服务器就需要为这些用户付出更多的处理成本。其二，RC4 算法能减轻 野兽攻击（BEAST）的危害，如果禁用 RC4 会导致 TLS 1.0 用户会换到更容易受攻击的 AES-CBC 算法上（通常服务器端的对野兽攻击（BEAST）的“修复方法”是让 RC4 优先于其它算法）。我认为 RC4 的风险要高于野兽攻击（BEAST）的风险。事实上，有了客户端缓解方案（Chrome 和 Firefox 提供了缓解方案），野兽攻击（BEAST）就不是什么大问题了。而 RC4 的风险却在增长：随着时间推移，对加密算法的破解会越来越多。</p>\n<h5 id=\"怪物攻击（FREAK）\"><a href=\"#怪物攻击（FREAK）\" class=\"headerlink\" title=\"怪物攻击（FREAK）\"></a>怪物攻击（FREAK）</h5><p>怪物攻击（FREAK）是一种中间人攻击，它是由来自<a href=\"https://www.smacktls.com/\" target=\"_blank\" rel=\"noopener\">INRIA、微软研究院和 IMDEA</a>的密码学家们所发现的。怪物攻击（FREAK）的缩写来自“Factoring RSA-EXPORT Keys（RSA 出口密钥因子分解）”</p>\n<p>这个漏洞可上溯到上世纪九十年代，当时美国政府禁止出口加密软件，除非其使用编码密钥长度不超过512位的出口加密套件。</p>\n<p>这造成了一些现在的 TLS 客户端存在一个缺陷，这些客户端包括： 苹果的 SecureTransport 、OpenSSL。这个缺陷会导致它们会接受出口降级 RSA 密钥，即便客户端并没有要求使用出口降级 RSA 密钥。这个缺陷带来的影响很讨厌：在客户端存在缺陷，且服务器支持出口降级 RSA 密钥时，会发生中间人攻击，从而导致连接的强度降低。</p>\n<p>攻击分为两个组成部分：首先是服务器必须接受“出口降级 RSA 密钥”。</p>\n<p>中间人攻击可以按如下流程：</p>\n<p>在客户端的 Hello 消息中，要求标准的 RSA 加密套件。<br>中间人攻击者修改该消息为‘export RSA’（输出级 RSA 密钥）。<br>服务器回应一个512位的输出级 RSA 密钥，并以其长期密钥签名。<br>由于 OpenSSL/SecureTransport 的缺陷，客户端会接受这个弱密钥。<br>攻击者根据 RSA 模数分解因子来恢复相应的 RSA 解密密钥。<br>当客户端编码‘pre-master secret’（预主密码）给服务器时，攻击者现在就可以解码它并恢复 TLS 的‘master secret’（主密码）。<br>从这里开始，攻击者就能看到了传输的明文并注入任何东西了。<br>本文所提供的加密套件不启用输出降级加密，请确认你的 OpenSSL 是最新的，也强烈建议你将客户端也升级到新的版本。</p>\n<h5 id=\"SSL-压缩（罪恶攻击-CRIME）\"><a href=\"#SSL-压缩（罪恶攻击-CRIME）\" class=\"headerlink\" title=\"SSL 压缩（罪恶攻击 CRIME）\"></a>SSL 压缩（罪恶攻击 CRIME）</h5><p>罪恶攻击（CRIME）使用 SSL 压缩来完成它的魔法，SSL 压缩在下述版本是默认关闭的： nginx 1.1.6及更高/1.0.9及更高（如果使用了 OpenSSL 1.0.0及更高）， nginx 1.3.2及更高/1.2.2及更高（如果使用较旧版本的 OpenSSL）。</p>\n<p>如果你使用一个早期版本的 nginx 或 OpenSSL，而且你的发行版没有向后移植该选项，那么你需要重新编译没有一个 ZLIB 支持的 OpenSSL。这会禁止 OpenSSL 使用 DEFLATE 压缩方式。如果你禁用了这个，你仍然可以使用常规的 HTML DEFLATE 压缩。</p>\n<h5 id=\"卷毛狗攻击（POODLE）和-TLS-FALLBACK-SCSV\"><a href=\"#卷毛狗攻击（POODLE）和-TLS-FALLBACK-SCSV\" class=\"headerlink\" title=\"卷毛狗攻击（POODLE）和 TLS-FALLBACK-SCSV\"></a>卷毛狗攻击（POODLE）和 TLS-FALLBACK-SCSV</h5><p>SSLv3 会受到<a href=\"https://raymii.org/s/articles/Check_servers_for_the_Poodle_bug.html\" target=\"_blank\" rel=\"noopener\">卷毛狗漏洞（POODLE）</a>的攻击。这是禁用 SSLv3 的主要原因之一。</p>\n<p>Google 提出了一个名为<a href=\"https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00\" target=\"_blank\" rel=\"noopener\">TLSFALLBACKSCSV</a>的SSL/TLS 扩展，它用于防止强制 SSL 降级。如果你升级 到下述的 OpenSSL 版本会自动启用它。</p>\n<ul>\n<li>OpenSSL 1.0.1 带有 TLS_FALLBACK_SCSV 1.0.1j 及更高。</li>\n<li>OpenSSL 1.0.0 带有 TLS_FALLBACK_SCSV 1.0.0o 及更高。</li>\n<li>OpenSSL 0.9.8 带有 TLS_FALLBACK_SCSV 0.9.8zc 及更高。<br><a href=\"http://wiki.nginx.org/HttpSslModule#ssl_protocols\" target=\"_blank\" rel=\"noopener\">更多信息请参照 NGINX 文档</a></li>\n</ul>\n<h4 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h4><h5 id=\"优先顺序的逻辑\"><a href=\"#优先顺序的逻辑\" class=\"headerlink\" title=\"优先顺序的逻辑\"></a>优先顺序的逻辑</h5><ul>\n<li>ECDHE+AESGCM 加密是首选的。它们是 TLS 1.2 加密算法，现在还没有广泛支持。当前还没有对它们的已知攻击。</li>\n<li>PFS 加密套件好一些，首选 ECDHE，然后是 DHE。</li>\n<li>AES 128 要好于 AES 256。有一个关于 AES256 带来的安全提升程度是否值回成本的讨论，结果是显而易见的。目前，AES128 要更值一些，因为它提供了不错的安全水准，确实很快，而且看起来对时序攻击更有抵抗力。</li>\n<li>在向后兼容的加密套件里面，AES 要优于 3DES。在 TLS 1.1及其以上，减轻了针对 AES 的野兽攻击（BEAST）的威胁，而在 TLS 1.0上则难以实现该攻击。在非向后兼容的加密套件里面，不支持 3DES。</li>\n<li>RC4 整个不支持了。3DES 用于向后兼容。参看<a href=\"https://wiki.mozilla.org/Security/Server_Side_TLS#RC4_weaknesses\" target=\"_blank\" rel=\"noopener\">#RC4_weaknesses</a>中的讨论。<h5 id=\"强制丢弃的算法\"><a href=\"#强制丢弃的算法\" class=\"headerlink\" title=\"强制丢弃的算法\"></a>强制丢弃的算法</h5></li>\n<li>aNULL 包含了非验证的 Diffie-Hellman 密钥交换，这会受到中间人（MITM）攻击</li>\n<li>eNULL 包含了无加密的算法（明文）</li>\n<li>EXPORT 是老旧的弱加密算法，是被美国法律标示为可出口的</li>\n<li>RC4 包含的加密算法使用了已弃用的 ARCFOUR 算法</li>\n<li>DES 包含的加密算法使用了弃用的数据加密标准（DES）</li>\n<li>SSLv2 包含了定义在旧版本 SSL 标准中的所有算法，现已弃用</li>\n<li>MD5 包含了使用已弃用的 MD5 作为哈希算法的所有算法</li>\n</ul>\n<h3 id=\"配置范例\"><a href=\"#配置范例\" class=\"headerlink\" title=\"配置范例\"></a>配置范例</h3><pre><code>server {\n\n  listen [::]:443 default_server;\n\n  ssl on;\n  ssl_certificate_key /etc/ssl/cert/raymii_org.pem;\n  ssl_certificate /etc/ssl/cert/ca-bundle.pem;\n\n  ssl_ciphers &#39;AES128+EECDH:AES128+EDH:!aNULL&#39;;\n\n  ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n  ssl_session_cache shared:SSL:10m;\n\n  ssl_stapling on;\n  ssl_stapling_verify on;\n  resolver 8.8.4.4 8.8.8.8 valid=300s;\n  resolver_timeout 10s;\n\n  ssl_prefer_server_ciphers on;\n  ssl_dhparam /etc/ssl/certs/dhparam.pem;\n\n  add_header Strict-Transport-Security max-age=63072000;\n  add_header X-Frame-Options DENY;\n  add_header X-Content-Type-Options nosniff;\n\n  root /var/www/;\n  index index.html index.htm;\n  server_name raymii.org;\n\n}</code></pre>","categories":[{"name":"技术","path":"api/categories/技术.json"}],"tags":[{"name":"教程","path":"api/tags/教程.json"}]}